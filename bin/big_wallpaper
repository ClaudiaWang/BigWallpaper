#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#    Copyright 2012-2013, Yale Huang, yale.huang@trantect.com
#
#    This file is part of BigWallpaper.
#
#    Pyrit is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    Pyrit is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with BigWallpaper.  If not, see <http://www.gnu.org/licenses/>.

from urllib2 import urlopen
from lxml.html import parse
from gi.repository import Gio, Gtk, GObject, AppIndicator3, Notify
from optparse import OptionParser

import threading
import tempfile
import os
import ConfigParser
import sys
import dbus.service

class WallPaperManager:
    # Manager must created before Controller

    SCHEMA = 'org.gnome.desktop.background'
    KEY = 'picture-uri'
    IMG_FILE = "big_wallpaper.jpg"
    URL_FILE = "big_wallpaper.url"
    DESKTOP_FILE = "big_wallpaper.desktop"
    AUTOSTART_DIR = os.path.expanduser("~/.config/autostart")

    def __init__(self, prefix_dir="share", img_dir='share/pixmaps'):
        self.update_lock = threading.Lock()
        self.prefix_dir = prefix_dir
        self.img_dir = img_dir

        self.img_file = "%s/%s" % (self.img_dir, self.IMG_FILE)
        self.url_file = "%s/%s" % (self.img_dir, self.URL_FILE)
        self.desktop_source_file = \
            "%s/%s" % (self.prefix_dir, self.DESKTOP_FILE)
        self.autostart_desktop_file = \
            "%s/%s" % (self.AUTOSTART_DIR, self.DESKTOP_FILE)
        self.real_img_file = None
        self.wp_url = None
        self.saved_url = None
    
    def get_autostart(self):
        return os.access(self.autostart_desktop_file, os.F_OK)
                       
    def update_autostart(self, autostart):
        try:
            os.unlink(self.autostart_desktop_file)
        except OSError:
            pass

        if autostart:
            f_source = open(self.desktop_source_file, "r")
            f_dest = open(self.autostart_desktop_file, "w")
            try:
                f_dest.write(f_source.read())
            finally:
                f_source.close()
                f_dest.close()

    def on_image_downloaded(self, image_file = None, url = None):
        self.update_gsettings(image_file = image_file, url = url)

    def update_gsettings(self, image_file = None, url = None):
        print "image_file = %s, url = %s" % (image_file, url)
        print "Current real_img_file = %s, saved_url = %s" % \
            (self.real_img_file, self.saved_url)
        if image_file is not None and image_file != self.real_img_file:
            # delete old image file, and update symbol link
            try:
                print "Delete old files..."
                if self.real_img_file is not None:
                    os.unlink(self.real_img_file) 
                os.unlink(self.img_file)
            except (IOError, OSError):
                pass

            print "Make new link: %s %s" % (image_file, self.img_file)
            os.symlink(image_file, self.img_file)
            self.real_img_file = image_file

        if url is not None:
            print "Saving URL %s to %s" % (url, self.url_file)
            self.saved_url = url

            f = open(self.url_file, "w")
            f.write(url)
            f.close()

        if self.real_img_file is not None and \
                self.wp_url != "file://" + self.real_img_file:
            gsettings = Gio.Settings.new(self.SCHEMA)
            gsettings.set_string(self.KEY, "file://" + self.real_img_file)
            GObject.idle_add(ui_controller.notify_wallpaper_update)

    def update_saved_content(self, image_file = None):
        # get saved URL
        try:
            f = open(self.url_file, "r")
            self.saved_url = f.readline()
            f.close()
        except IOError:
            pass

        # get saved image file name
        try:
            self.real_img_file = os.readlink(self.img_file)
        except OSError:
            pass
            
        # gsettings get org.gnome.desktop.background picture-uri
        gsettings = Gio.Settings.new(self.SCHEMA)
        self.wp_url = gsettings.get_string(self.KEY)

    def correct_link(self):
        try:
            os.mkdir(self.img_dir)
        except OSError:
            pass
        self.update_saved_content()
        self.update_gsettings()

    def update(self):
        print "Updating..."
        download_thread = WallPaperManager.DownloadThread(self)
        download_thread.start()

    def generate_img_file(self, suffix):
        return tempfile.mkstemp(suffix=suffix, dir=self.img_dir)

    class DownloadThread(threading.Thread):
        def __init__(self, manager):
            super(WallPaperManager.DownloadThread, self).__init__()
            self.manager = manager

        def run(self):
            global ui_controller

            if not self.manager.update_lock.acquire(False):
                # is updaing now, just return
                return

            GObject.idle_add(ui_controller.start_updating)

            try:
                print "Get URL..."

                url = self.get_bigpicture_url()
                print url

                if manager.saved_url is not None:
                    print manager.saved_url

                if url is not None and url == manager.saved_url:
                    # Duplicated URL, don't download
                    print "Duplicated URL"
                    return

                temp_file = manager.generate_img_file(".jpg")
                self.download_img_file(temp_file[0], url)
                print "Downloaded %s: %s" % (url, temp_file[1])

                manager.on_image_downloaded(image_file = temp_file[1], 
                                            url = url)
            finally:
                GObject.idle_add(ui_controller.finish_updating)
                self.manager.update_lock.release()

        def get_bigpicture_url(self):
            page = urlopen('http://www.boston.com/bigpicture')
            p = parse(page)
            i = p.xpath('/descendant::img[@class="bpImage"]')[0]
            return i.get('src')

        def download_img_file(self, fd, url):
            img = urlopen(url)
            f = os.fdopen(fd, 'w')
            f.write(img.read())
            f.close()

class UpdateTimer:
    def __init__(self, interval=1800000):
        self.interval = interval
        self.timer_id = GObject.timeout_add(interval, self.on_timer)

    def on_timer(self):
        global manager

        if manager is not None:
            manager.update()

        return True # continue

class AnimationTimer:
    def __init__(self, interval, icons):
        self.interval = interval
        self.icons = icons
        self.current_icon_index = 0
        
        ui_controller.update_appindicator( \
            self.icons[self.current_icon_index])

        self.timer_id = GObject.timeout_add(self.interval, self.on_timer)

    def cancel(self):
        GObject.source_remove(self.timer_id)
        self.timer_id = None

    def on_timer(self):
        try:
            self.current_icon_index += 1
            self.current_icon_index %= len(self.icons)

            ui_controller.update_appindicator( \
                self.icons[self.current_icon_index])
        finally:
            return True # continue

class UIController:
    ICON_FILE = 'big_wallpaper_small.png'
    UPDATING_ICON_FILES = ['big_wallpaper_updating_1.png',
                           'big_wallpaper_updating_2.png',
                           'big_wallpaper_updating_3.png',
                           'big_wallpaper_updating_4.png',
                           'big_wallpaper_updating_5.png']
    
    def __init__(self, icon_dir=None):
        global manager, config

        self.animation_timer = None

        self.icon_dir = icon_dir

        self.ind = AppIndicator3.Indicator.new ( \
            "BigWallpaper",
            "%s/%s" % (self.icon_dir, self.ICON_FILE),
            AppIndicator3.IndicatorCategory.APPLICATION_STATUS)
        self.ind.set_status (AppIndicator3.IndicatorStatus.ACTIVE)

        # create a menu
        self.menu = Gtk.Menu()

        self.update_item = Gtk.MenuItem('Update Now')
        self.update_item.connect("activate",
                                 lambda obj: manager.update())

        self.auto_start_item = Gtk.CheckMenuItem('Start with System')
        self.auto_start_item.set_active(manager.get_autostart())
        self.auto_start_item.connect( \
            "toggled",
            lambda obj: \
                manager.update_autostart(self.auto_start_item.get_active()))

        self.save_item = Gtk.MenuItem("Save Preference")
        self.save_item.connect("activate",
                               lambda obj: config.save())

        self.sep_item = Gtk.SeparatorMenuItem()

        self.quit_item = Gtk.MenuItem('Quit')
        self.quit_item.connect("activate", Gtk.main_quit)

        self.menu.append(self.update_item)
        self.menu.append(self.auto_start_item)
        self.menu.append(self.save_item)
        self.menu.append(self.sep_item)
        self.menu.append(self.quit_item)
        self.menu.show_all()

        self.ind.set_menu(self.menu)

    def start_updating(self):
        self.update_item.set_sensitive(False)
        self.update_item.set_label("Updating...")

        self.animation_timer = AnimationTimer( \
            500,
            map(lambda s: "%s/%s" % (self.icon_dir, s),
                self.UPDATING_ICON_FILES) )

    def finish_updating(self):
        self.update_item.set_sensitive(True)
        self.update_item.set_label("Update Now")

        if self.animation_timer is not None:
            self.animation_timer.cancel()
            self.animation_timer = None

        self.ind.set_icon("%s/%s" % (self.icon_dir, self.ICON_FILE))

    def update_appindicator(self, icon):
        self.ind.set_icon(icon)

    def show_message_dialog(self, title, message):
        dialog = Gtk.MessageDialog(None, 0, Gtk.MessageType.INFO,
                                   Gtk.ButtonsType.OK, title)
        dialog.format_secondary_text(message)
        dialog.run()
        dialog.destroy()

    def notify_wallpaper_update( \
        self, title="New Wallpaper",
        body="A new wallpaper was updated by BigWallpaper."):
        if not Notify.init ("BigWallpaper"):
            return
        n = Notify.Notification.new(title, body,
                                    "dialog-information")
        n.show ()

DBUS_APPNAME='com.trantect.BigWallpaper'

class DBusService(dbus.service.Object):
    def __init__(self):
        name = dbus.service.BusName(DBUS_APPNAME, bus = dbus.SessionBus())
        dbus.service.Object.__init__( self, name, 
                                      "/com/trantect/BigWallpaper")
    
    @dbus.service.method(dbus_interface=DBUS_APPNAME)
    def run(self):
        self.app.window.present()

class Config:
    BIGWALLPAPER_SECTION = "BigWallpaper"

    def __init__(self, args):
        parser = OptionParser()
        parser.add_option("-c", "--config-file", dest="config", default="",
                          metavar="FILE", help="Config file")
        parser.add_option("-p", "--prefix", dest="prefix", type="string",
                          help="path prefix for app resources",
                          default="/usr/share/big_wallpaper")
        parser.add_option("-d", "--dest", dest="dest", type="string",
                          help="dest dir for download image files",
                          default=os.path.expanduser('~/.big_wallpaper'))
        parser.add_option("-i", "--interval", dest="interval", type="int",
                          help="interval of updating in seconds",
                          default=1800000)

        # Actually, only CONFIG is necessary for this parse_arg()
        (self.options, pending_args) = parser.parse_args(args)

        config = ConfigParser.SafeConfigParser()

        if self.options.config:
            config.read(self.options.config)
        else:
            config.read(['big_wallpaper.conf',
                         os.path.expanduser('~/.big_wallpaper.conf')])
        try:
            defaults = dict(config.items(self.BIGWALLPAPER_SECTION))
        except ConfigParser.NoSectionError:
            defaults = {}
        print defaults

        # Parse again with default values from config file
        parser.set_defaults(**defaults)
        (self.options, args) = parser.parse_args(args)

        print self.options

    def get_options(self):
        return self.options

    def save(self):
        config = ConfigParser.SafeConfigParser()

        config.add_section(self.BIGWALLPAPER_SECTION)

        config.set(self.BIGWALLPAPER_SECTION, 'interval',
                   "%d" % self.options.interval)
        config.set(self.BIGWALLPAPER_SECTION, 'dest', 
                   self.options.dest)
        config.set(self.BIGWALLPAPER_SECTION, 'prefix', 
                   self.options.prefix)

        f = None

        f = open(self.options.config if self.options.config \
                     else os.path.expanduser('~/.big_wallpaper.conf'), 
                 'wb')

        if f:
            try:
                config.write(f)
            finally:
                f.close()

if __name__ == "__main__":
    global manager, timer, ui_controller, config
    
    if dbus.SessionBus().request_name(DBUS_APPNAME) != \
            dbus.bus.REQUEST_NAME_REPLY_PRIMARY_OWNER:
        print "Application already running!"
        exit(1)

    config = Config(sys.argv)

    GObject.threads_init()
    manager = WallPaperManager( \
         prefix_dir = os.path.expanduser(config.get_options().prefix),
         img_dir=os.path.expanduser(config.get_options().dest))

    timer = UpdateTimer(interval=config.get_options().interval)
    ui_controller = UIController( \
        icon_dir = os.path.expanduser( \
            config.get_options().prefix+"/pixmaps"))

    manager.correct_link()
    Gtk.main()
